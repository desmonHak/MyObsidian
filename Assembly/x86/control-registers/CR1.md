https://www.pagetable.com/?p=364
¿Por qué no hay [[CR1]]? ¿Y por qué los registros de control son un desastre?

Si desea habilitar el [[Assembly/MODOS/modo-protegido]] o la [[modelos-memoria#^cd416f|paginación]] en la arquitectura `i386`/``x86_64``, debe usar [[CR0]], que es la abreviatura de registro de ``control 0``. Tiene sentido. Se trata de configuraciones importantes del sistema. __Pero si desea cambiar el formato de la tabla de paginación__, debe cambiar un bit en [[CR4]] ([[CR1]] no existe y [[CR2]] y [[CR3]] no contienen ``bits de control``), **si desea cambiar al modo de ``64 bits``, debe cambiar un bit en un [[MSR]]**, oh, y si desea activar el "paso a paso único"([[single-stepping]]), eso está en realidad en sus ``FLAGS``. Además, ¿he mencionado que [[CR5]] a [[CR15]] no existen, excepto [[CR8]], por supuesto?

Al igual que muchas (pero desafortunadamente no todas) peculiaridades de la arquitectura ``i386``/``x86_64``, este lío se puede explicar con la historia.

### [[8086]] – FLAGS (BANDERAS)
La historia de ``x86`` comienza típicamente con el [[8086]] de ``16 bits``, pero aunque no era compatible a nivel binario con su predecesor, era sin embargo una extensión de ``16 bits`` compatible a nivel de ensamblaje bastante sencilla del Intel [[8080]] de ``8 bits`` con algunas ideas del ``Zilog`` [[Z80]]. El [[8086]] sigue siendo una ``CPU`` clásica de “clase de computadora doméstica”, que no estaba pensada para sistemas operativos modernos: no tenía [[MMU]] de ningún tipo, ni concepto de modos privilegiados y no privilegiados. Por lo tanto, los bits de control que vemos como estado del sistema hoy en día se codificaron en el registro [[FLAGS]] de ``16 bits``: el ``bit de habilitación de interrupción``([[IF]]) y la bandera de trampa([[TF]]) (que causará una interrupción de software después de la siguiente instrucción y, por lo tanto, le permite realizar un solo paso) están codificados en [[FLAGS]] justo al lado de las banderas de la [[ALU]] como Zero([[ZF]]) y Carry([[CF]]).

### [[80286]] – Palabra de estado de la máquina
El [[80286]] llegó con una forma sencilla de gestión de memoria que permitía ejecutar sistemas operativos más sofisticados (pero todavía no “modernos”), como las versiones originales de ``OS/2``. La “Palabra de estado de la máquina” de ``16 bits`` se creó para albergar el gran cambio entre el ``modo heredado`` ([[Assembly/MODOS/modo-real]]) y el nuevo modo de gestión de memoria ([[Assembly/MODOS/modo-protegido]]), y un programa podía acceder a ella utilizando las nuevas instrucciones “[[LMSW]]” y “[[SMSW]]”. El [[80286]] tenía más estado del sistema que solo este bit: el [[GDT]], el [[IDT]] y el [[TSS]] tenían sus propios registros e instrucciones dedicadas para acceder a ellos (“[[LGDT]]”/”[[SGDT]]”, “[[LIDT]]”/”[[SIDT]]”, “[[LTR]]”/”[[STR]]”)

[[i80386]]/i386 – Registros de control
El i386 finalmente tuvo una [[MMU]] real que permitió la [[modelos-memoria#^cd416f|paginación]] y, por lo tanto, los sistemas operativos modernos. La [[MMU]] requería dos registros más en el estado del sistema, uno para la __dirección base de las tablas de paginación__ y __otro para leer una dirección de falla__. Intel decidió no agregar más registros de propósito especial con instrucciones de acceso dedicadas, pero en su lugar introdujo ocho “registros de control” indexados de ``32 bits`` de ancho, [[CR0]] a [[CR7]]. Los nuevos accesores “``mov crn, r32``”/”``mov r32, crn``” permitían copiar entre registros y registros de control y tenían el índice ``CR`` de ``3 bits`` codificado en el código de operación.

El antiguo [[MSW]] también estaba conectado a los ``16 bits`` inferiores de [[CR0]]; pero [[CR0]] también se amplió con nuevos bits como el interruptor para activar la paginación. [[CR1]] se mantuvo reservado, presumiblemente como un segundo registro de control para bits de control diversos, y __[[CR2]] y [[CR3]] se usaron para la dirección de falla y el puntero base de la tabla de paginación__ antes mencionados. Los códigos de operación para acceder a los registros de control reservados generaron un error de “``código de operación no válido``”, lo que hizo posible que Intel reutilizara los códigos de operación más adelante si no usaba los registros de control.

### [[i80486]]/i486 – [[CR4]]
El ``i486`` agregó algunos bits de control más y algunos de ellos se instalaron en [[CR0]]. Pero en lugar de desbordar los nuevos bits en [[CR1]], Intel decidió omitirlo y abrir [[CR4]] en su lugar, por razones desconocidas.

### Pentium – [[MSR]]
En el Pentium, Intel agregó por primera vez bits de control que eran una propiedad de la implementación en lugar de la arquitectura, es decir, bits que son específicos de la microarquitectura y, por lo tanto, solo funcionarán en ciertas CPU y no necesariamente serán compatibles con CPU posteriores, como detalles de almacenamiento en caché y configuraciones de depuración. Para no desperdiciar el valioso espacio CR con bits de control desechables, Intel introdujo los registros específicos del modelo (MSR). El espacio de direcciones del MSR es de 32 bits y cada MSR tiene 64 bits de ancho. Las dos nuevas instrucciones “rdmsr” y “wrmsr” copian entre un MSR indexado por ECX y los registros EDX:EAX.

### Pentium II – [[SYSENTER]] MSR
La instrucción SYSENTER que se introdujo en el Pentium II es una forma rápida de cambiar entre el modo privilegiado y el modo no privilegiado. En lugar de buscar el segmento de destino, el puntero de instrucción y el puntero de pila en la memoria, la CPU guarda esta información en tres registros de sistema de propósito especial. El espacio CR es valioso, por lo que Intel decidió no llenar CR5, CR6 y CR7, por lo que lo colocó en el espacio de direcciones MSR, en 0x174 a 0x176. Esto fue prácticamente un abuso del concepto MSR.