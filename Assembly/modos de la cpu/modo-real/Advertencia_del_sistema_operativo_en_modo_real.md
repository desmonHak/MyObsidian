El uso de las funciones del [[BIOS]] (y "evitar" la necesidad de escribir controladores) puede parecer más fácil para los principiantes que no saben nada al respecto, pero a la larga hace que todo sea mucho más difícil. Esto lo convierte en una trampa atractiva para los incautos.

El propósito de esta página es advertir a los principiantes para que no se conviertan en víctimas desprevenidas de la trampa. Esta página no tiene como objetivo evitar que las personas que están familiarizadas con todos los peligros decidan caer intencionalmente en la trampa.

## La [[BIOS]] está obsoleta

Actualmente, toda la industria (todos los fabricantes de `PC` "`80x86`" y todos los sistemas operativos para `PC` "`80x86`") están migrando a [[UEFI]]. Al final de esta transición (en algún momento en el futuro), la [[BIOS]] dejará de existir. Confiar en la existencia de funciones de la [[BIOS]] no es una opción a largo plazo. Confiar temporalmente en la existencia de funciones de la [[BIOS]] (a corto plazo) hace que sea mucho más difícil portar el sistema operativo a [[UEFI]] más adelante, y también hace que sea mucho más difícil portar el sistema operativo a otras plataformas (`ARM`, `SPARC`, etc.) porque todo para lo que se usaba la [[BIOS]] debe reemplazarse.

Nota: Intel ha declarado oficialmente que dejará de brindar soporte a la [[BIOS]] (pasará de "[[BIOS]]+[[UEFI]] híbrido" a "solo [[UEFI]]") antes del año `2020`; y algunas personas esperan que la principal razón de `Intel` para hacer esto es poder empezar a eliminar hardware obsoleto de sus chipsets (empezando por la compuerta [[A20]], y posiblemente incluyendo [[PIC]], [[PIT]], [[PS/2]], áreas de `ROM` heredadas y emulación [[VGA]]).

## El [[BIOS]] no es compatible con todos los dispositivos

El [[BIOS]] no ofrece _compatibilidad con sonido_, _tarjetas de red_ (con la excepción de una tarjeta de red si y solo si inició con [[PXE]]), _impresoras modernas_, _escáneres_, _módems_ (de voz, datos o fax), _GPU_ (para gráficos acelerados por hardware y/o [[GPGPU]]), _monitores múltiples_ (solo un monitor), _varios sensores_ (de movimiento, luz, ubicación/GPS, etc.) o algunos dispositivos de entrada de usuario (ratón, joystick, volante, seguimiento de la cabeza en cascos _3D_, detección de movimiento/Kinect, pantallas táctiles, tabletas utilizadas con lápiz, micrófonos, lectores de códigos de barras, etc.).

Para cualquiera o todas estas cosas, deberá escribir sus propios controladores.

## La [[BIOS]] no es compatible con ningún dispositivo
El `firmware` (incluidos la [[BIOS]] y la [[UEFI]]) está pensado principalmente para proporcionar la funcionalidad mínima necesaria para iniciar un sistema operativo y, por este motivo (para los dispositivos que sí son compatibles), no son compatibles con los dispositivos. Tenga en cuenta que la mayoría de los problemas se aplican tanto a la [[BIOS]] como a la [[UEFI]], y la mayoría de los problemas se aplican incluso si está escribiendo un sistema operativo de "[[modo-real]] de una sola tarea".

### Hora y temporizadores
La compatibilidad con la "hora del día" solo tiene una precisión de 1 segundo (y no una precisión de subsegundos); y la función de alarma está limitada a las siguientes 24 horas y también tiene una precisión de solo 1 segundo. La compatibilidad con el "tiempo transcurrido" se basa en la peor/más lenta configuración del PIT, lo que le otorga una precisión deficiente (~55 ms) sin compatibilidad con "llamar a mi devolución de llamada después de la duración". La función del [[BIOS]] para obtener el tiempo transcurrido se basa en "ticks desde la medianoche" y tiene varios problemas que involucran el cambio de hora (por ejemplo, tratar de determinar la cantidad de tiempo entre "justo antes de la medianoche" y "justo después de la medianoche" es un poco complicado y te molestará si no lo tienes en cuenta; y no puedes medir nada más largo que 1 día sin un sondeo intermitente porque no sabes cuántas medianoches han pasado entre la "hora de inicio" y la "hora de finalización").
### Puertos seriales
El código del puerto serial del [[BIOS]] utiliza sondeo para enviar y recibir bytes (y no hay "buffers FIFO"). Esto significa que es casi imposible utilizar las funciones del [[BIOS]] para que los puertos seriales reciban datos sin perderlos, y casi imposible utilizar las funciones del [[BIOS]] para que los puertos seriales envíen datos sin grandes problemas de rendimiento.

### Vídeo
Las funciones del [[BIOS]] para vídeo (incluidas las extensiones [[VBE]]/[[VESA_BIOS]]) no permiten nada más que cambiar los modos de vídeo y escribir en la memoria de visualización (no hay bit-blits rápidos, ni puntero de ratón de hardware, ni sincronización vertical, etc.). Para cambiar el modo de vídeo, la cantidad de modos suele ser muy limitada y, a menudo, ni siquiera se puede configurar la resolución nativa/preferida del monitor (lo que genera una imagen borrosa/mala debido al escalado realizado por el monitor). Para escribir en la memoria de visualización, el rendimiento es intolerable (cientos de ciclos de hinchazón adicional por cada píxel escrito).
### Teclado
La compatibilidad del teclado del [[BIOS]] tiene un pequeño búfer y utiliza sondeo, por lo que si no se realiza el sondeo con la suficiente frecuencia (y el usuario escribe lo suficientemente rápido), se pierden las pulsaciones de teclas. Tampoco hay compatibilidad para preguntar si se está presionando una tecla específica en ese momento o no, no hay compatibilidad con los LED del teclado, no hay compatibilidad con diferentes diseños de teclado, no hay forma de hacer una búsqueda inversa (determinar el nombre de la tecla a partir del código de escaneo), no hay compatibilidad con "no [[ASCII]]" (necesario para la internacionalización) y no hay compatibilidad con "conexión en caliente" (extracción/inserción de dispositivos y [[KVM]] antiguos que utilizan un interruptor mecánico).

### Dispositivos de disco/almacenamiento
La compatibilidad del [[BIOS]] con estos dispositivos es sincrónica, lo que causa graves problemas de rendimiento. Por ejemplo, si desea descomprimir un archivo de un dispositivo y escribir los datos en otro, no puede tener una secuencia de `buffers` y leer desde un dispositivo mientras la `CPU` descomprime mientras escribe datos descomprimidos en el otro dispositivo; debe leer desde el primer dispositivo (mientras que el segundo dispositivo y la `CPU` no hacen nada), luego descomprimir (mientras que ambos dispositivos no hacen nada) y luego escribir en el otro dispositivo (mientras que el primer dispositivo y la `CPU` no hacen nada). Tampoco puede obtener datos con anterioridad en segundo plano ni implementar una caché de disco de "escritura diferida" efectiva (donde las escrituras se realizan en segundo plano).

En el caso de los medios extraíbles (disquetes, `CD`, cintas), no hay ninguna notificación cuando se insertan o extraen los medios. Esto puede provocar la corrupción de los datos; por ejemplo, el usuario extrae un disquete e inserta otro, pero el SO sigue pensando que el primer disquete está presente y escribe en él, corrompiendo accidentalmente el segundo disquete. Si bien es posible intentar evitar esto (por ejemplo, siempre verificar si el primer sector es diferente antes de realizar cualquier lectura o escritura), esto causa más problemas de rendimiento.

Para dispositivos `hot-plug` (todos los discos `SATA`, todos los dispositivos `USB`, etc.) no hay soporte para `hot-plug`. Por ejemplo, si el usuario desconecta un dispositivo flash `USB` (o disco duro `SATA` o...) no hay ninguna notificación (la lectura/escritura en el dispositivo simplemente causa un error) y si el usuario conecta un dispositivo flash `USB` (o disco duro `SATA` o...) no hay forma de que el SO lo use (el [[BIOS]] continúa fingiendo que el dispositivo no existe).

No existe el concepto de prioridades de `E/S` ni forma de cancelar una transferencia "en proceso". Esto significa que si necesita transferir datos lo antes posible, esa transferencia debe esperar hasta que se complete cualquier transferencia "en proceso" menos importante.

No hay soporte para "`trim`" (para `SSD` y flash `USB`), no hay soporte para "borrado seguro", no hay soporte para "eject" (para unidades de `CD`), no hay soporte para monitorear la salud del dispositivo ("Tecnología de automonitoreo, análisis e informes"), no hay soporte para discos duros con sectores de `4 KiB` (determinar si la unidad tiene sectores de `4 KiB` o no), y no hay soporte para "barreras de escritura" o determinar si los datos realmente se han escrito en el medio y no solo se han almacenado en el búfer de la unidad (necesario para garantizar que las fallas de energía no puedan causar corrupción del sistema de archivos).

### CPU
El [[BIOS]] está diseñado únicamente para manejar una sola `CPU`. Puede utilizar varias `CPU`, pero no puede permitir de forma segura que dos o más `CPU` llamen a funciones del [[BIOS]] al mismo tiempo y necesita un "bloqueo del [[BIOS]]" para garantizar que eso no suceda. También existe el riesgo de que llamar al [[BIOS]] desde cualquier `CPU` que no sea la BSP ("`CPU` de arranque") pueda causar problemas (ya sea debido a errores del [[BIOS]] o por otras razones).

## El [[BIOS]] le impide hacer algo bien
El [[BIOS]] espera que una variedad de dispositivos de hardware (`PIC`, `PIT`, [[RTC]], controlador [[PS/2]], controladores de disco, etc.) estén en un determinado estado predeterminado. Parte de este hardware está obsoleto y reemplazado (y emulado) por dispositivos más modernos (`PIC` reemplazado por `IO APIC`, `PIT` reemplazado por `HPET`, etc.). Un sistema operativo no puede utilizar hardware moderno sin alterar el estado predeterminado de los dispositivos que el [[BIOS]] espera y, por lo tanto, no puede utilizar hardware moderno sin romper el [[BIOS]].

Esto hace que sea extremadamente difícil para un sistema operativo hacer algo correctamente (incluidos los controladores de dispositivos que el [[BIOS]] no admite) mientras sigue utilizando el [[BIOS]].

## La [[BIOS]] le impide aprender cosas útiles

Al final (para escribir un `SO` que sea realmente útil o para aprender a escribir un SO que sea realmente útil), un desarrollador de `SO` necesita aprender varias cosas, como cómo funcionan los dispositivos, cómo se pueden usar los controladores de interrupciones, cómo se puede realizar la entrada y salida de forma asincrónica, etc. Conocer estas cosas (incluso si su `SO` no las hace) es lo que lo convierte en un buen/mejor desarrollador de `SO`. No aprende ninguna de estas cosas confiando en la [[BIOS]].

## La [[BIOS]] te lleva a un diseño extremadamente deficiente

Para los principiantes que usan la [[BIOS]], es natural (debido a la falta de experiencia/conocimiento) que diseñen las interfaces de los controladores de dispositivos de su sistema operativo para que sean similares a las interfaces proporcionadas por la [[BIOS]], y luego es natural diseñar las interfaces/API para las capas superiores (por ejemplo, sistemas de archivos, etc.) para que se adapten a las interfaces de los controladores, y luego es natural diseñar las interfaces/API del espacio de usuario para que se adapten tanto a las interfaces de los controladores como a las capas superiores.

Esto significa que existe un riesgo extremo de que el diseño (muy malo y defectuoso) de la [[BIOS]] se filtre en todo el sistema operativo; de modo que incluso si el desarrollador del sistema operativo logra superar todos los demás problemas causados ​​por el uso de la [[BIOS]] (por ejemplo, y reemplaza todo el uso de la [[BIOS]] con sus propios controladores nativos, etc.), aún se queda con un sistema operativo dañado que tiene cicatrices permanentes.